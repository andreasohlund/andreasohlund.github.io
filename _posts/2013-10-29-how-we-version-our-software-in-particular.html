---
layout: post
title: How we version our software - in Particular
date: 2013-10-29 17:54:08.000000000 +01:00
categories:
- Particularities
tags: []
status: publish
type: post
published: true
meta:
  _edit_last: '1'
  dsq_thread_id: '1915301855'
author:
  login: andreas.ohlund
  email: andreasohlund2@gmail.com
  display_name: Andreas Öhlund
  first_name: Andreas
  last_name: "Öhlund"

---
<p>In my last post I talked about how <a href="http://andreasohlund.net/2013/10/09/build-scripts-in-particular/">we aim to have a release build in Visual Studio produce production ready binaries</a>. Obviously for something to be production ready it must have a version in order for users know what they're actually using. Just to clarify, when I talk about versioning in this post I refer to the technical version, most likely following <a href="http://semver.org/">SemVer</a>, that you give the artifacts you release. I'm not taking about the marketing version that you might brand your things with.</p>
<p>The strategies for technical versioning I've seen can be split into 2 camps:</p>
<ol>
<li>Have the build server determine the version</li>
<li>Commit version information into the repository it self</li>
</ol>
<p>Since we want the version to be correct even when you go back in time and build older branches and tags #1 is ruled out. Other drawbacks with this strategy is that you need to have the build server up and running to produce a release meaningful version. We <a href="http://andreasohlund.net/2013/10/09/build-scripts-in-particular/">definitely want a local build to generate a good version</a> so that puts us firmly in camp #2.</p>
<p>At this time 2 different forces where in play, firstly we didn't like all those "Bumping version to X" commits cluttering our repos. And a process like that cause a lot of emails from users saying "the latest release have the wrong version, did you forget to change it?" appear in your inbox. Secondly since <a href="http://andreasohlund.net/2013/10/07/the-pain-and-suffering-of-large-source-code-repositories/">we're moving to a multi repository model</a> we needed to ensure that we use a consistent branching model across our repositories. Why is that important? Trust me spending the first few brain cycles on figuring out where to start coding every time you switch repo is definitely a drag on productivity.</p>
<p>For us the branching model we've decided to go with is <a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> and as we started to discuss our versioning scheme we realized that if we follow the GitFlow model and also adhere to <a href="http://semver.org">SemVer</a> we can deduct the version based on the branch names and merge commits in Git. If we could pull that off we could kill 2 birds with one stone, version information is now embedded in the repo without dreaded "bumping to X" commits and we could also enforce our branching model by failing the build if we detected illegal commits and branch names. As an example a commit straight to "master" is not valid using <a href="http://nvie.com/posts/a-successful-git-branching-model/">GitFlow</a> since the head will always point to either a merge commit for  a hotfix or release branch.</p>
<h2>GitFlowVersion was born</h2>
<p><img class="alignleft" src="assets/package_icon.png" alt="" width="100" height="100" />I'm not going into full detail on the algorithm as its already documented <a href="https://github.com/Particular/GitFlowVersion/blob/master/README.md">here</a> but in short the develop branch is always one minor version above the master. Master is always the SemVer version of the latest merge commit (eg: hotfix-4.1.1 or release-4.3.0) and so on.</p>
<p>We use GFV across all our repos and so far it seems to hold up.  The major hurdles so far has been all the quirks in NuGet that we've had to work around since the version generated by GitFlowVersion also is used to version our NuGet packages. One of the main snags was that NuGet has no concept of builds  and since we use NuGet-packages to manage dependencies across repositories we need to make sure that our develop branch always outputs packages that sorts highest at all time. This forced us to give our develop builds the "Unstable" pr-erelease suffix. This makes sure that they stay on top since Unstable &gt; Beta, RC, etc. I'll go into more details on how we do our cross repo dependencies in an upcoming post so stay tuned!</p>
<p>Here is the NServiceBus repository being versioned by GFV:  (the number you see is the PR number that's assigned by GitHub)</p>
<p>&nbsp;</p>
<h2><a href="http://andreasohlund.net/wp-content/uploads/2013/10/Screenshot-2013-10-27-11.21.10.png"><img class="size-full wp-image-589 alignnone" title="Screenshot 2013-10-27 11.21.10" src="assets/Screenshot-2013-10-27-11.21.10.png" alt="" width="729" height="152" /></a></h2>
<p>&nbsp;</p>
<h2><span style="font-size: 1.5em;">TL;DR;</span></h2>
<p>Use <a href="https://github.com/Particular/GitFlowVersion">GitFlowVersion</a> to automatically version your code without mucking around with either the buildserver or VERSION.txt files...</p>
<p><a href="https://github.com/Particular/GitFlowVersion/">https://github.com/Particular/GitFlowVersion</a></p>
